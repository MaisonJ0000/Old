### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String!
  user: User!
}

type BatchPayload {
  count: Int!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input FindManyReviewArgs {
  orderBy: ReviewOrderByInput
  skip: Int
  take: Int
  where: ReviewWhereInput
}

type FriendRequest {
  id: Int!
  isAccepted: Boolean
  requestUserId: Int!
  targetUserId: Int
}

input FriendRequestCreateInput {
  createdAt: DateTime
  isAccepted: Boolean
  requestUserId: Int!
  targetUserId: Int
  updatedAt: DateTime
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Movie {
  genre: String
  id: Int!
  imdbId: String
  poster: String
  reviews: [Review!]!
  titleEn: String
  titleKr: String!
  year: String
}

input MovieCreateInput {
  createdAt: DateTime
  genre: String
  imdbId: String
  poster: String
  reviews: ReviewCreateManyWithoutMovieInput
  titleEn: String
  titleKr: String!
  updatedAt: DateTime
  year: String
}

input MovieCreateOneWithoutReviewsInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewsInput
}

input MovieCreateWithoutReviewsInput {
  createdAt: DateTime
  genre: String
  imdbId: String
  poster: String
  titleEn: String
  titleKr: String!
  updatedAt: DateTime
  year: String
}

input MovieOrderByInput {
  createdAt: SortOrder
  genre: SortOrder
  id: SortOrder
  imdbId: SortOrder
  poster: SortOrder
  titleEn: SortOrder
  titleKr: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input MovieUpdateInput {
  createdAt: DateTime
  genre: String
  imdbId: String
  poster: String
  reviews: ReviewUpdateManyWithoutMovieInput
  titleEn: String
  titleKr: String
  updatedAt: DateTime
  year: String
}

input MovieUpdateOneRequiredWithoutReviewsInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewsInput
  update: MovieUpdateWithoutReviewsDataInput
  upsert: MovieUpsertWithoutReviewsInput
}

input MovieUpdateWithoutReviewsDataInput {
  createdAt: DateTime
  genre: String
  imdbId: String
  poster: String
  titleEn: String
  titleKr: String
  updatedAt: DateTime
  year: String
}

input MovieUpsertWithoutReviewsInput {
  create: MovieCreateWithoutReviewsInput!
  update: MovieUpdateWithoutReviewsDataInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  createdAt: DateTimeFilter
  genre: NullableStringFilter
  id: IntFilter
  imdbId: NullableStringFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  poster: NullableStringFilter
  reviews: ReviewFilter
  titleEn: NullableStringFilter
  titleKr: StringFilter
  updatedAt: DateTimeFilter
  year: NullableStringFilter
}

input MovieWhereUniqueInput {
  id: Int
}

type Mutation {
  acceptFriend(requestId: Int): User!
  createOneFriendRequest(data: FriendRequestCreateInput!): FriendRequest!
  createOneMovie(data: MovieCreateInput!): Movie!
  createOneReview(data: ReviewCreateInput!): Review!
  createOneUser(data: UserCreateInput!): User!
  createReview(data: ReviewCreateWithoutAuthorInput): Review!
  deleteMovie(where: MovieWhereUniqueInput): Movie!
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  deleteOneReview(where: ReviewWhereUniqueInput!): Review
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteReview(where: ReviewWhereUniqueInput): Review!
  deleteUser: User!
  login(email: String, password: String): AuthPayload!
  requestFriend(friend: UserWhereUniqueInput): FriendRequest!
  signUp(email: String, name: String, password: String): AuthPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateMovie(data: MovieUpdateInput, where: MovieWhereUniqueInput): Movie!
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateOneReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateReview(data: ReviewUpdateInput, where: ReviewWhereUniqueInput): Review!
  updateUser(data: UserUpdateInput): User!
}

input NullableFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  me: User
  movie(where: MovieWhereUniqueInput!): Movie
  movies(orderBy: [MovieOrderByInput!], skip: Int, where: MovieWhereInput): [Movie!]!
  myReviews(query: FindManyReviewArgs): [Review!]!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(orderBy: [ReviewOrderByInput!], skip: Int, where: ReviewWhereInput): [Review!]!
  user(where: UserWhereUniqueInput!): User
  users(orderBy: [UserOrderByInput!], skip: Int, where: UserWhereInput): [User!]!
}

type Review {
  author: User!
  id: Int!
  movie: Movie!
  rating: Float
  text: String
}

input ReviewCreateInput {
  author: UserCreateOneWithoutReviewsInput!
  createdAt: DateTime
  movie: MovieCreateOneWithoutReviewsInput!
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewCreateManyWithoutAuthorInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutAuthorInput!]
}

input ReviewCreateManyWithoutMovieInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutMovieInput!]
}

input ReviewCreateWithoutAuthorInput {
  createdAt: DateTime
  movie: MovieCreateOneWithoutReviewsInput!
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewCreateWithoutMovieInput {
  author: UserCreateOneWithoutReviewsInput!
  createdAt: DateTime
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewFilter {
  every: ReviewWhereInput
  none: ReviewWhereInput
  some: ReviewWhereInput
}

input ReviewOrderByInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  movieId: SortOrder
  rating: SortOrder
  text: SortOrder
  updatedAt: SortOrder
}

input ReviewScalarWhereInput {
  AND: [ReviewScalarWhereInput!]
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  movieId: IntFilter
  NOT: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  rating: NullableFloatFilter
  text: NullableStringFilter
  updatedAt: DateTimeFilter
}

input ReviewUpdateInput {
  author: UserUpdateOneRequiredWithoutReviewsInput
  createdAt: DateTime
  movie: MovieUpdateOneRequiredWithoutReviewsInput
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewUpdateManyDataInput {
  createdAt: DateTime
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewUpdateManyWithoutAuthorInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutAuthorInput!]
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutAuthorInput!]
}

input ReviewUpdateManyWithoutMovieInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutMovieInput!]
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutMovieInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutMovieInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  data: ReviewUpdateManyDataInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateWithoutAuthorDataInput {
  createdAt: DateTime
  movie: MovieUpdateOneRequiredWithoutReviewsInput
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewUpdateWithoutMovieDataInput {
  author: UserUpdateOneRequiredWithoutReviewsInput
  createdAt: DateTime
  rating: Float
  text: String
  updatedAt: DateTime
}

input ReviewUpdateWithWhereUniqueWithoutAuthorInput {
  data: ReviewUpdateWithoutAuthorDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithWhereUniqueWithoutMovieInput {
  data: ReviewUpdateWithoutMovieDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutAuthorInput {
  create: ReviewCreateWithoutAuthorInput!
  update: ReviewUpdateWithoutAuthorDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutMovieInput {
  create: ReviewCreateWithoutMovieInput!
  update: ReviewUpdateWithoutMovieDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewWhereInput {
  AND: [ReviewWhereInput!]
  author: UserWhereInput
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  movie: MovieWhereInput
  movieId: IntFilter
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  rating: NullableFloatFilter
  text: NullableStringFilter
  updatedAt: DateTimeFilter
}

input ReviewWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Subscription {
  friendRequest(myRequests: Boolean): FriendRequest!
}

type User {
  email: String!
  friends: [User!]!
  id: Int!
  name: String
  reviews: [Review!]!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  friends: UserCreateManyWithoutUserInput
  name: String
  password: String!
  reviews: ReviewCreateManyWithoutAuthorInput
  updatedAt: DateTime
  User: UserCreateOneWithoutFriendsInput
}

input UserCreateManyWithoutUserInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutUserInput!]
}

input UserCreateOneWithoutFriendsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutFriendsInput
}

input UserCreateOneWithoutReviewsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewsInput
}

input UserCreateWithoutFriendsInput {
  createdAt: DateTime
  email: String!
  name: String
  password: String!
  reviews: ReviewCreateManyWithoutAuthorInput
  updatedAt: DateTime
  User: UserCreateOneWithoutFriendsInput
}

input UserCreateWithoutReviewsInput {
  createdAt: DateTime
  email: String!
  friends: UserCreateManyWithoutUserInput
  name: String
  password: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutFriendsInput
}

input UserCreateWithoutUserInput {
  createdAt: DateTime
  email: String!
  friends: UserCreateManyWithoutUserInput
  name: String
  password: String!
  reviews: ReviewCreateManyWithoutAuthorInput
  updatedAt: DateTime
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  friends: UserFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  reviews: ReviewFilter
  updatedAt: DateTimeFilter
  userId: NullableIntFilter
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  friends: UserUpdateManyWithoutUserInput
  name: String
  password: String
  reviews: ReviewUpdateManyWithoutAuthorInput
  updatedAt: DateTime
  User: UserUpdateOneWithoutFriendsInput
}

input UserUpdateManyDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateManyWithoutUserInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutUserInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutUserInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutReviewsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewsInput
  update: UserUpdateWithoutReviewsDataInput
  upsert: UserUpsertWithoutReviewsInput
}

input UserUpdateOneWithoutFriendsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutFriendsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutFriendsDataInput
  upsert: UserUpsertWithoutFriendsInput
}

input UserUpdateWithoutFriendsDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  reviews: ReviewUpdateManyWithoutAuthorInput
  updatedAt: DateTime
  User: UserUpdateOneWithoutFriendsInput
}

input UserUpdateWithoutReviewsDataInput {
  createdAt: DateTime
  email: String
  friends: UserUpdateManyWithoutUserInput
  name: String
  password: String
  updatedAt: DateTime
  User: UserUpdateOneWithoutFriendsInput
}

input UserUpdateWithoutUserDataInput {
  createdAt: DateTime
  email: String
  friends: UserUpdateManyWithoutUserInput
  name: String
  password: String
  reviews: ReviewUpdateManyWithoutAuthorInput
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutUserInput {
  data: UserUpdateWithoutUserDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutFriendsInput {
  create: UserCreateWithoutFriendsInput!
  update: UserUpdateWithoutFriendsDataInput!
}

input UserUpsertWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput!
  update: UserUpdateWithoutReviewsDataInput!
}

input UserUpsertWithWhereUniqueWithoutUserInput {
  create: UserCreateWithoutUserInput!
  update: UserUpdateWithoutUserDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  friends: UserFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  reviews: ReviewFilter
  updatedAt: DateTimeFilter
  User: UserWhereInput
  userId: NullableIntFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
